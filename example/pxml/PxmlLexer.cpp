/** generated by ParGen **/
#include "PxmlLexer.hpp"


namespace PXML {


using namespace Tokens;

PxmlLexer::PxmlLexer(std::filesystem::path path, std::istream& stream) :
  stream(stream), state(45)
{
    current = fetch();
    pos.path = path;
}

PxmlLexer::Chars::Chars(std::initializer_list<Chars::char_t> init) : min(init.begin()[0]){
    if(init.size() == 1){
        max = init.begin()[0];
    }else{
        max = init.begin()[1];
    }
}

bool PxmlLexer::Chars::operator<(const Chars& rhs) const {
    return (min < rhs.min) && (max < rhs.min);
}

PxmlLexer::Chars::char_t PxmlLexer::fetch(){
    std::string line_end = "";
    Chars::char_t res = stream.get();
    if(res != std::istream::traits_type::eof()){
        line_end += res;
        text += res;
        if(line_end.size() > 2){
            line_end = line_end.substr(line_end.size() - 2);
        }
        if(text.ends_with("\n")){
            cur.line += 1;
            cur.column = 0;
        }else{
            cur.column += 1;
        }
    }
    return res;
}

std::vector<PxmlLexer::State> PxmlLexer::states = {
    /* comment */
    {{{37},2}, {{123},3}, }, // S0
    {}, // S1
    {{{125},5}, }, // S2
    {{{37},6}, }, // S3
    {}, // S4
    {}, // S5
    {}, // S6
    /* tail */
    {{{9,13},8}, {{32},8}, {{62},9}, {{123},10}, }, // S7
    {{{9,13},8}, {{32},8}, }, // S8
    {}, // S9
    {{{37},11}, }, // S10
    {}, // S11
    /* tag */
    {{{9,13},13}, {{32},13}, {{34},14}, {{43},15}, {{45},15}, {{47},16}, {{48,57},17}, {{61},18}, {{62},19}, {{65,90},20}, {{95},20}, {{97,101},20}, {{102},21}, {{103,115},20}, {{116},22}, {{117,122},20}, {{123},23}, }, // S12
    {{{9,13},13}, {{32},13}, }, // S13
    {}, // S14
    {{{48,57},17}, }, // S15
    {{{9,13},24}, {{32},24}, {{62},25}, }, // S16
    {{{46},26}, {{48,57},17}, {{69},27}, {{101},27}, }, // S17
    {}, // S18
    {}, // S19
    {{{48,57},28}, {{65,90},28}, {{95},28}, {{97,122},28}, }, // S20
    {{{48,57},28}, {{65,90},28}, {{95},28}, {{97},29}, {{98,122},28}, }, // S21
    {{{48,57},28}, {{65,90},28}, {{95},28}, {{97,113},28}, {{114},30}, {{115,122},28}, }, // S22
    {{{37},31}, }, // S23
    {{{9,13},24}, {{32},24}, {{62},25}, }, // S24
    {}, // S25
    {{{48,57},32}, {{69},27}, {{101},27}, }, // S26
    {{{43},33}, {{45},33}, {{48,57},34}, }, // S27
    {{{48,57},28}, {{65,90},28}, {{95},28}, {{97,122},28}, }, // S28
    {{{48,57},28}, {{65,90},28}, {{95},28}, {{97,107},28}, {{108},35}, {{109,122},28}, }, // S29
    {{{48,57},28}, {{65,90},28}, {{95},28}, {{97,116},28}, {{117},36}, {{118,122},28}, }, // S30
    {}, // S31
    {{{48,57},32}, {{69},27}, {{101},27}, }, // S32
    {{{48,57},34}, }, // S33
    {{{48,57},34}, }, // S34
    {{{48,57},28}, {{65,90},28}, {{95},28}, {{97,114},28}, {{115},37}, {{116,122},28}, }, // S35
    {{{48,57},28}, {{65,90},28}, {{95},28}, {{97,100},28}, {{101},38}, {{102,122},28}, }, // S36
    {{{48,57},28}, {{65,90},28}, {{95},28}, {{97,100},28}, {{101},39}, {{102,122},28}, }, // S37
    {{{48,57},28}, {{65,90},28}, {{95},28}, {{97,122},28}, }, // S38
    {{{48,57},28}, {{65,90},28}, {{95},28}, {{97,122},28}, }, // S39
    /* string */
    {{{34},41}, {{92},42}, }, // S40
    {{{34},43}, {{92},42}, }, // S41
    {{{0},44}, }, // S42
    {}, // S43
    {{{34},43}, {{92},42}, }, // S44
    /*  */
    {{{-1},47}, {{9,13},48}, {{32},48}, {{38},49}, {{60},50}, {{92},51}, {{123},52}, }, // S45
    {{{60},46}, {{92},51}, }, // S46
    {}, // S47
    {{{9,13},48}, {{32},48}, }, // S48
    {{{97},53}, {{103},54}, {{108},55}, {{113},56}, }, // S49
    {{{33},57}, {{47},58}, {{65,90},59}, {{97,122},59}, }, // S50
    {{{60},60}, }, // S51
    {{{37},61}, }, // S52
    {{{109},62}, {{112},63}, }, // S53
    {{{116},64}, }, // S54
    {{{116},65}, }, // S55
    {{{117},66}, }, // S56
    {{{68},67}, }, // S57
    {{{65,90},68}, {{97,122},68}, }, // S58
    {{{48,57},69}, {{65,90},69}, {{97,122},69}, }, // S59
    {{{60},46}, {{92},51}, }, // S60
    {}, // S61
    {{{112},70}, }, // S62
    {{{111},71}, }, // S63
    {{{59},72}, }, // S64
    {{{59},72}, }, // S65
    {{{111},73}, }, // S66
    {{{79},74}, }, // S67
    {{{48,57},75}, {{65,90},75}, {{97,122},75}, }, // S68
    {{{48,57},69}, {{65,90},69}, {{97,122},69}, }, // S69
    {{{59},72}, }, // S70
    {{{115},76}, }, // S71
    {}, // S72
    {{{116},77}, }, // S73
    {{{67},78}, }, // S74
    {{{48,57},75}, {{65,90},75}, {{97,122},75}, }, // S75
    {{{59},72}, }, // S76
    {{{59},72}, }, // S77
    {{{84},79}, }, // S78
    {{{89},80}, }, // S79
    {{{80},81}, }, // S80
    {{{69},82}, }, // S81
    {{{32},83}, }, // S82
    {{{112},84}, }, // S83
    {{{120},85}, }, // S84
    {{{109},86}, }, // S85
    {{{108},87}, }, // S86
    {{{62},88}, }, // S87
    {}, // S88
};

Token PxmlLexer::get(){
    if(current == std::istream::traits_type::eof()){
        return Token(std::monostate(), pos);
    }
    while(current != std::istream::traits_type::eof()){
        if(states[state].contains(current)){
            state = states[state][current];
            current = fetch();
        }else if(states[state].contains('\0')){
            state = states[state]['\0'];
            current = fetch();
        }else{
            Position _pos = pos;
            pos = cur;
            std::string _text = text.substr(0, text.size() - 1);
            switch(state){
                // Action 0
                case 88:
                    state = 45;
                    text = current;
                {
                    return Token(Doctype(), _pos);
                }break;
                // Action 1
                case 61:
                    stack.emplace_back(45, text);
                    state = 0;
                    text = current;
                break;
                // Action 2
                case 6:
                    stack.emplace_back(0, text);
                    state = 0;
                    text = current;
                break;
                // Action 3
                case 5:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                break;
                // Action 4
                case 1:
                case 4:
                    state = 0;
                    text = current;
                break;
                // Action 5
                case 68:
                case 75:
                    stack.emplace_back(45, text);
                    state = 7;
                break;
                // Action 6
                case 11:
                    stack.emplace_back(7, text);
                    state = 0;
                    text = current;
                break;
                // Action 7
                case 9:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                {
                    return Token(Tail(_text.substr(2, _text.size() - 3)), _pos);
                }break;
                // Action 8
                case 8:
                    state = 7;
                    text = current;
                break;
                // Action 9
                case 59:
                case 69:
                    stack.emplace_back(45, text);
                    state = 12;
                    text = current;
                {
                    return Token(Tag(_text.substr(1)), _pos);
                }break;
                // Action 10
                case 31:
                    stack.emplace_back(12, text);
                    state = 0;
                    text = current;
                break;
                // Action 11
                case 25:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                {
                    return Token(Inline(), _pos);
                }break;
                // Action 12
                case 19:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                {
                    return Token(Close(), _pos);
                }break;
                // Action 13
                case 14:
                    stack.emplace_back(12, text);
                    state = 40;
                    text = current;
                break;
                // Action 14
                case 18:
                    state = 12;
                    text = current;
                {
                    return Token(Equal(), _pos);
                }break;
                // Action 15
                case 38:
                case 39:
                    state = 12;
                    text = current;
                {
                    return Token(Bool(_text == "true"), _pos);
                }break;
                // Action 16
                case 20:
                case 21:
                case 22:
                case 28:
                case 29:
                case 30:
                case 35:
                case 36:
                case 37:
                    state = 12;
                    text = current;
                {
                    return Token(ID(_text), _pos);
                }break;
                // Action 17
                case 17:
                case 26:
                case 32:
                case 34:
                    state = 12;
                    text = current;
                {
                    return Token(Number(std::stod(_text)), _pos);
                }break;
                // Action 18
                case 13:
                    state = 12;
                    text = current;
                break;
                // Action 19
                case 43:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                {
                    return Token(String(_text.substr(0, _text.size() - 1)), _pos);
                }break;
                // Action 20
                case 72:
                    state = 45;
                    text = current;
                {
                    return Token(Entity(_text), _pos);
                }break;
                // Action 21
                case 48:
                    state = 45;
                    text = current;
                {
                    return Token(Space(_text), _pos);
                }break;
                // Action 22
                case 46:
                case 60:
                    state = 45;
                    text = current;
                {
                    return Token(Text(_text), _pos);
                }break;
                // Action 23
                case 47:
                    state = 45;
                    text = current;
                {
                    return Token(std::monostate(), _pos);
                }break;
                default:
                    throw UnknownToken(_pos, text);
            }
        }
    }
}

const char* UnknownToken::what(){
    return msg.c_str();
}

} // namespace PXML


