/** generated by ParGen **/
#include "PxmlParser.hpp"

static PXML::Position to_pos(ParsePxml::Position pos){
    return PXML::Position {.path = pos.path, .line = pos.line, .column = pos.column};
}
        
#include <stack>
#include <list>
#include <variant>
#include <vector>
#include <algorithm>
#include <array>

namespace ParsePxml {

using namespace Tokens;

PxmlParser::PxmlParser(PxmlLexer& lexer) : lexer(lexer) {}

std::pair<PxmlParser::term_t, PxmlParser::token_t> PxmlParser::fetch(){
    if(!buffer.empty()){
        auto token = buffer.front();
        buffer.pop_front();
        return token;
    }
    Token res = lexer.get();
    return {res.index() + 1, res};
}

static PXML::Pxml action_1(PxmlParser& _this, std::vector<Position> _pos, Tokens::Doctype _op0, std::string _op1, PXML::Pxml _op2, std::string _op3){
    return _op2;
}
static std::list<PXML::Pxml::Child> action_2(PxmlParser& _this, std::vector<Position> _pos, PXML::Pxml _op0, std::list<PXML::Pxml::Child> _op1){
    _op1.emplace_front(to_pos(_pos[0]), _op0);
    return _op1;
}
static std::list<PXML::Pxml::Child> action_3(PxmlParser& _this, std::vector<Position> _pos, std::string _op0, std::list<PXML::Pxml::Child> _op1){
    _op1.emplace_front(to_pos(_pos[0]), _op0);
    return _op1;
}
static std::list<PXML::Pxml::Child> action_4(PxmlParser& _this, std::vector<Position> _pos){
    return {};
}
static PXML::Pxml action_5(PxmlParser& _this, std::vector<Position> _pos, Tokens::Tag _op0, std::map<std::string, PXML::Value> _op1, Tokens::Close _op2, std::list<PXML::Pxml::Child> _op3, Tokens::Tail _op4){
    PXML::Position pos = to_pos(_pos[0]);
    if(_op0.value != _op4.value){
        throw Exception::SyntaxError("tag not match", pos);
    }
    PXML::Pxml elem {.tag = _op0.value, .pos = pos};
    elem.swap(_op1);
    elem.children.swap(_op3);
    return elem;
}
static PXML::Pxml action_6(PxmlParser& _this, std::vector<Position> _pos, Tokens::Tag _op0, std::map<std::string, PXML::Value> _op1, Tokens::Inline _op2){
    PXML::Pxml elem {.tag = _op0.value, .pos = to_pos(_pos[0])};
    elem.swap(_op1);
    return elem;
}
static std::string action_7(PxmlParser& _this, std::vector<Position> _pos, Tokens::Space _op0, std::string _op1){
    return _op0.value + _op1;
}
static std::string action_8(PxmlParser& _this, std::vector<Position> _pos){
    return "";
}
static std::string action_9(PxmlParser& _this, std::vector<Position> _pos, Tokens::Text _op0, std::string _op1){
    return _op0.value + _op1;
}
static std::string action_10(PxmlParser& _this, std::vector<Position> _pos, Tokens::Space _op0, std::string _op1){
    return _op0.value + _op1;
}
static std::string action_11(PxmlParser& _this, std::vector<Position> _pos, Tokens::Entity _op0, std::string _op1){
    return _op0.value + _op1;
}
static std::string action_12(PxmlParser& _this, std::vector<Position> _pos){
    return std::string();
}
static std::map<std::string, PXML::Value> action_13(PxmlParser& _this, std::vector<Position> _pos, std::pair<std::string, PXML::Value> _op0, std::map<std::string, PXML::Value> _op1){
    _op1.emplace(_op0);
    return _op1;
}
static std::map<std::string, PXML::Value> action_14(PxmlParser& _this, std::vector<Position> _pos, Tokens::Space _op0, std::map<std::string, PXML::Value> _op1){
    return _op1;
}
static std::map<std::string, PXML::Value> action_15(PxmlParser& _this, std::vector<Position> _pos){
    return {};
}
static std::pair<std::string, PXML::Value> action_16(PxmlParser& _this, std::vector<Position> _pos, Tokens::ID _op0, Tokens::Equal _op1, PXML::Value _op2){
    return {_op0.value, _op2};
}
static std::pair<std::string, PXML::Value> action_17(PxmlParser& _this, std::vector<Position> _pos, Tokens::ID _op0){
    return {_op0.value, {to_pos(_pos[0]), std::monostate()}};
}
static PXML::Value action_18(PxmlParser& _this, std::vector<Position> _pos, Tokens::Bool _op0){
    return {to_pos(_pos[0]), _op0.value};
}
static PXML::Value action_19(PxmlParser& _this, std::vector<Position> _pos, Tokens::Number _op0){
    return {to_pos(_pos[0]), _op0.value};
}
static PXML::Value action_20(PxmlParser& _this, std::vector<Position> _pos, Tokens::String _op0){
    return {to_pos(_pos[0]), _op0.value};
}

std::vector<PxmlParser::State> PxmlParser::table = {
    {{2, {{3,{}},}},{19, {{5,{}},}},},
    {{8, {{7,{}},}},{14, {{9,{}},}},{18, {{11,{}},}},{20, {{13,{}},}},},
    {{1, {{0,{}},}},},
    {{4, {{15,{}},}},{5, {{17,{}},}},{12, {{19,{}},}},{14, {{21,{}},}},{15, {{23,{}},}},{16, {{25,{}},}},},
    {{8, {{14,{1,0,}},}},{14, {{9,{}},}},{20, {{27,{}},}},},
    {{1, {{2,{1,0,1,0,}},}},{14, {{29,{}},}},{20, {{31,{}},}},},
    {{8, {{7,{}},}},{18, {{33,{}},}},},
    {{8, {{35,{}},}},{9, {{37,{}},}},{11, {{39,{}},}},{13, {{41,{}},}},{14, {{43,{}},}},{17, {{45,{}},}},{18, {{47,{}},}},{21, {{49,{}},}},},
    {{1, {{12,{1,0,1,}},}},{14, {{12,{1,0,1,}},}},},
    {{3, {{51,{}},}},{4, {{34,{1,}},}},{5, {{34,{1,}},}},{12, {{34,{1,}},}},{14, {{34,{1,}},}},},
    {{4, {{28,{1,0,}},}},{5, {{28,{1,0,}},}},{12, {{19,{}},}},{14, {{21,{}},}},{15, {{23,{}},}},{16, {{53,{}},}},},
    {{4, {{26,{1,0,}},}},{5, {{26,{1,0,}},}},{12, {{19,{}},}},{14, {{21,{}},}},{15, {{23,{}},}},{16, {{55,{}},}},},
    {{4, {{57,{}},}},{5, {{59,{}},}},},
    {{8, {{14,{1,1,}},}},},
    {{1, {{14,{1,0,}},}},{14, {{29,{}},}},{20, {{61,{}},}},},
    {{1, {{2,{1,0,1,1,}},}},},
    {{1, {{2,{1,1,1,0,}},}},{14, {{29,{}},}},{20, {{63,{}},}},},
    {{4, {{65,{}},}},{5, {{67,{}},}},{12, {{19,{}},}},{14, {{21,{}},}},{15, {{23,{}},}},{16, {{69,{}},}},},
    {{1, {{10,{1,0,1,0,1,}},}},{14, {{10,{1,0,1,0,1,}},}},},
    {{8, {{18,{1,0,}},}},{9, {{18,{1,0,}},}},{11, {{39,{}},{18,{1,0,}},}},{13, {{41,{}},{18,{1,0,}},}},{14, {{43,{}},{18,{1,0,}},}},{21, {{71,{}},}},},
    {{8, {{22,{1,0,}},}},{9, {{22,{1,0,}},}},{11, {{39,{}},{22,{1,0,}},}},{13, {{41,{}},{22,{1,0,}},}},{14, {{43,{}},{22,{1,0,}},}},{21, {{73,{}},}},},
    {{8, {{20,{1,0,}},}},{9, {{20,{1,0,}},}},{11, {{39,{}},{20,{1,0,}},}},{13, {{41,{}},{20,{1,0,}},}},{14, {{43,{}},{20,{1,0,}},}},{21, {{75,{}},}},},
    {{9, {{77,{}},}},},
    {{8, {{35,{}},}},{9, {{4,{1,0,}},}},{11, {{39,{}},}},{13, {{41,{}},}},{14, {{43,{}},}},{17, {{79,{}},}},{18, {{47,{}},}},{21, {{49,{}},}},},
    {{8, {{35,{}},}},{9, {{6,{1,0,}},}},{11, {{39,{}},}},{13, {{41,{}},}},{14, {{43,{}},}},{17, {{81,{}},}},{18, {{47,{}},}},{21, {{49,{}},}},},
    {{6, {{83,{}},}},{7, {{85,{}},}},{10, {{87,{}},}},{22, {{89,{}},}},},
    {{4, {{28,{1,1,}},}},{5, {{28,{1,1,}},}},},
    {{4, {{26,{1,1,}},}},{5, {{26,{1,1,}},}},},
    {{8, {{35,{}},}},{9, {{91,{}},}},{11, {{39,{}},}},{13, {{41,{}},}},{14, {{43,{}},}},{17, {{93,{}},}},{18, {{47,{}},}},{21, {{49,{}},}},},
    {{1, {{12,{1,1,1,}},}},{14, {{12,{1,1,1,}},}},},
    {{1, {{14,{1,1,}},}},},
    {{1, {{2,{1,1,1,1,}},}},},
    {{8, {{35,{}},}},{9, {{95,{}},}},{11, {{39,{}},}},{13, {{41,{}},}},{14, {{43,{}},}},{17, {{97,{}},}},{18, {{47,{}},}},{21, {{49,{}},}},},
    {{8, {{12,{1,0,1,}},}},{9, {{12,{1,0,1,}},}},{11, {{12,{1,0,1,}},}},{13, {{12,{1,0,1,}},}},{14, {{12,{1,0,1,}},}},},
    {{4, {{99,{}},}},{5, {{101,{}},}},},
    {{8, {{18,{1,1,}},}},{9, {{18,{1,1,}},}},{11, {{18,{1,1,}},}},{13, {{18,{1,1,}},}},{14, {{18,{1,1,}},}},},
    {{8, {{22,{1,1,}},}},{9, {{22,{1,1,}},}},{11, {{22,{1,1,}},}},{13, {{22,{1,1,}},}},{14, {{22,{1,1,}},}},},
    {{8, {{20,{1,1,}},}},{9, {{20,{1,1,}},}},{11, {{20,{1,1,}},}},{13, {{20,{1,1,}},}},{14, {{20,{1,1,}},}},},
    {{1, {{10,{1,0,1,1,1,}},}},{14, {{10,{1,0,1,1,1,}},}},},
    {{9, {{4,{1,1,}},}},},
    {{9, {{6,{1,1,}},}},},
    {{4, {{36,{1,}},}},{5, {{36,{1,}},}},{12, {{36,{1,}},}},{14, {{36,{1,}},}},},
    {{4, {{38,{1,}},}},{5, {{38,{1,}},}},{12, {{38,{1,}},}},{14, {{38,{1,}},}},},
    {{4, {{40,{1,}},}},{5, {{40,{1,}},}},{12, {{40,{1,}},}},{14, {{40,{1,}},}},},
    {{4, {{32,{1,1,1,}},}},{5, {{32,{1,1,1,}},}},{12, {{32,{1,1,1,}},}},{14, {{32,{1,1,1,}},}},},
    {{1, {{10,{1,1,1,0,1,}},}},{14, {{10,{1,1,1,0,1,}},}},},
    {{9, {{103,{}},}},},
    {{8, {{10,{1,0,1,0,1,}},}},{9, {{10,{1,0,1,0,1,}},}},{11, {{10,{1,0,1,0,1,}},}},{13, {{10,{1,0,1,0,1,}},}},{14, {{10,{1,0,1,0,1,}},}},},
    {{9, {{105,{}},}},},
    {{8, {{35,{}},}},{9, {{107,{}},}},{11, {{39,{}},}},{13, {{41,{}},}},{14, {{43,{}},}},{17, {{109,{}},}},{18, {{47,{}},}},{21, {{49,{}},}},},
    {{8, {{12,{1,1,1,}},}},{9, {{12,{1,1,1,}},}},{11, {{12,{1,1,1,}},}},{13, {{12,{1,1,1,}},}},{14, {{12,{1,1,1,}},}},},
    {{1, {{10,{1,1,1,1,1,}},}},{14, {{10,{1,1,1,1,1,}},}},},
    {{8, {{10,{1,0,1,1,1,}},}},{9, {{10,{1,0,1,1,1,}},}},{11, {{10,{1,0,1,1,1,}},}},{13, {{10,{1,0,1,1,1,}},}},{14, {{10,{1,0,1,1,1,}},}},},
    {{8, {{10,{1,1,1,0,1,}},}},{9, {{10,{1,1,1,0,1,}},}},{11, {{10,{1,1,1,0,1,}},}},{13, {{10,{1,1,1,0,1,}},}},{14, {{10,{1,1,1,0,1,}},}},},
    {{9, {{111,{}},}},},
    {{8, {{10,{1,1,1,1,1,}},}},{9, {{10,{1,1,1,1,1,}},}},{11, {{10,{1,1,1,1,1,}},}},{13, {{10,{1,1,1,1,1,}},}},{14, {{10,{1,1,1,1,1,}},}},},
};

PXML::Pxml PxmlParser::parse(){
    // Prepare
    std::stack<Stack::iterator> branches;
    Stack stack;
    stack.push(fetch(), 0);
    auto throw_error = [&](token_t token, term_t term){
        if(branches.empty()){
            throw ParseError(token.pos, term);
        }
        auto& saved = branches.top();
        auto buf_top = buffer.begin();
        Stack::iterator new_head = stack.begin();
        for(auto it = stack.begin(); (it != stack.end()) && (it != saved); it = std::next(it)){
            new_head = it;
            if(std::holds_alternative<token_t>(it->elem)){
                buffer.emplace(buf_top, it->term, std::get<token_t>(it->elem));
            }else{
                auto flattened = std::get<Node>(it->elem).flatten();
                buffer.insert(buf_top, flattened.begin(), flattened.end());
            }
        }
        new_head->branch += 1;
        new_head->term = buffer.front().first;
        new_head->elem = buffer.front().second;
        buffer.pop_front();
        stack.erase(stack.begin(), new_head);
    };
    // Parse
    while(stack.front().state != End){
        Entry& entry = stack.front();
        State& state = table[entry.state];
        if(state.contains(entry.term)){
            std::vector<Act>& acts = state[entry.term];
            if(entry.branch == 0){
                if(acts.size() > 1){
                    branches.emplace(std::next(stack.begin()));
                }
            }else if(entry.branch == acts.size() - 1){
                branches.pop();
            }
            Act& act = acts[entry.branch];
            if(act.first & 1){ // Shift
                stack.push(fetch(), act.first >> 1);
            }else{ // Reduce
                if(std::holds_alternative<token_t>(entry.elem)){
                    buffer.emplace_front(entry.term, std::get<token_t>(entry.elem));
                    stack.pop_front();
                }
                stack.reduce(act.first >> 1, act.second);
            }
        }else{
            Entry* ptr = &entry;
            while(std::holds_alternative<Node>(ptr->elem)){
                ptr = &std::get<Node>(ptr->elem).children.front();
            }
            if(std::holds_alternative<token_t>(ptr->elem)){
                throw_error(std::get<token_t>(ptr->elem), entry.term);
            }else{
                throw_error(Token(std::monostate(), Position()), entry.term);
            }
        }
    }
    // Expand tree
    return expand_tree(stack.back());
}

void PxmlParser::Stack::reduce(size_t action, std::vector<bool> param_toggle){
    static const std::vector<term_t> signatures {19,17,17,17,18,18,20,20,21,21,21,21,16,16,16,15,15,22,22,22,};
    if(action == 0){
        emplace_front(Entry {.term = 0, .state = End});
        return;
    }
    Node node = {.action = action, .param_toggle = param_toggle};
    size_t param_count = std::count_if(param_toggle.begin(), param_toggle.end(), [](bool val){return val;});
    for(size_t i = 0; i < param_count; ++i){
        node.children.emplace_front(front());
        pop_front();
    }
    Entry* head = &node.children.front();
    while(std::holds_alternative<Node>(head->elem)){
        Node& child = std::get<Node>(head->elem);
        head = &child.children.front();
    }
    Entry& entry = emplace_front();
    entry.term = signatures[action - 1];
    entry.state = head->state;
    entry.elem.emplace<Node>(node);
}

using item_t = std::variant<std::monostate,
    PxmlParser::token_t,
    PXML::Pxml,
    PXML::Value,
    std::list<PXML::Pxml::Child>,
    std::map<std::string, PXML::Value>,
    std::pair<std::string, PXML::Value>,
    std::string
>;

PXML::Pxml PxmlParser::expand_tree(Entry& tree){
    std::list<std::variant<Node, token_t>> entry_stack;
    std::list<std::pair<Position, item_t>> param_stack;
    auto extract_entry = [&](Entry& entry){
        if(std::holds_alternative<token_t>(entry.elem)){
            entry_stack.emplace_front(std::get<token_t>(entry.elem));
        }else if(std::holds_alternative<Node>(entry.elem)){
            Node& elem = std::get<Node>(entry.elem);
            Node& node = std::get<Node>(entry_stack.emplace_front(Node {.action = elem.action, .param_toggle = elem.param_toggle}));
            node.children.swap(elem.children);
        }
    };
    extract_entry(tree);
    auto invoke_action = [&](Node& node){
        std::vector<Position> positions(node.param_toggle.size());
        std::vector<item_t> params(node.param_toggle.size());
        Position pos;
        for(size_t i = node.param_toggle.size(); i > 0; --i){
            size_t index = i - 1;
            if(node.param_toggle[index]){
                positions[index] = param_stack.front().first;
                params[index] = param_stack.front().second;
                param_stack.pop_front();
            }
        }
        for(size_t i = 0; i < node.param_toggle.size(); ++i){
            if(node.param_toggle[i]){
                pos = positions[i];
                break;
            }
        }
        switch(node.action){
            case 1: 
                param_stack.emplace_front(pos, action_1(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Doctype>(std::get<Token>(params[0])) : Tokens::Doctype(),
                    node.param_toggle[1] ? std::get<std::string>(params[1]) : std::string(),
                    node.param_toggle[2] ? std::get<PXML::Pxml>(params[2]) : PXML::Pxml(),
                    node.param_toggle[3] ? std::get<std::string>(params[3]) : std::string()
                ));
            break;
            case 2: 
                param_stack.emplace_front(pos, action_2(*this, positions,
                    node.param_toggle[0] ? std::get<PXML::Pxml>(params[0]) : PXML::Pxml(),
                    node.param_toggle[1] ? std::get<std::list<PXML::Pxml::Child>>(params[1]) : std::list<PXML::Pxml::Child>()
                ));
            break;
            case 3: 
                param_stack.emplace_front(pos, action_3(*this, positions,
                    node.param_toggle[0] ? std::get<std::string>(params[0]) : std::string(),
                    node.param_toggle[1] ? std::get<std::list<PXML::Pxml::Child>>(params[1]) : std::list<PXML::Pxml::Child>()
                ));
            break;
            case 4: 
                param_stack.emplace_front(pos, action_4(*this, positions
                ));
            break;
            case 5: 
                param_stack.emplace_front(pos, action_5(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Tag>(std::get<Token>(params[0])) : Tokens::Tag(),
                    node.param_toggle[1] ? std::get<std::map<std::string, PXML::Value>>(params[1]) : std::map<std::string, PXML::Value>(),
                    node.param_toggle[2] ? std::get<Tokens::Close>(std::get<Token>(params[2])) : Tokens::Close(),
                    node.param_toggle[3] ? std::get<std::list<PXML::Pxml::Child>>(params[3]) : std::list<PXML::Pxml::Child>(),
                    node.param_toggle[4] ? std::get<Tokens::Tail>(std::get<Token>(params[4])) : Tokens::Tail()
                ));
            break;
            case 6: 
                param_stack.emplace_front(pos, action_6(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Tag>(std::get<Token>(params[0])) : Tokens::Tag(),
                    node.param_toggle[1] ? std::get<std::map<std::string, PXML::Value>>(params[1]) : std::map<std::string, PXML::Value>(),
                    node.param_toggle[2] ? std::get<Tokens::Inline>(std::get<Token>(params[2])) : Tokens::Inline()
                ));
            break;
            case 7: 
                param_stack.emplace_front(pos, action_7(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Space>(std::get<Token>(params[0])) : Tokens::Space(),
                    node.param_toggle[1] ? std::get<std::string>(params[1]) : std::string()
                ));
            break;
            case 8: 
                param_stack.emplace_front(pos, action_8(*this, positions
                ));
            break;
            case 9: 
                param_stack.emplace_front(pos, action_9(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Text>(std::get<Token>(params[0])) : Tokens::Text(),
                    node.param_toggle[1] ? std::get<std::string>(params[1]) : std::string()
                ));
            break;
            case 10: 
                param_stack.emplace_front(pos, action_10(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Space>(std::get<Token>(params[0])) : Tokens::Space(),
                    node.param_toggle[1] ? std::get<std::string>(params[1]) : std::string()
                ));
            break;
            case 11: 
                param_stack.emplace_front(pos, action_11(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Entity>(std::get<Token>(params[0])) : Tokens::Entity(),
                    node.param_toggle[1] ? std::get<std::string>(params[1]) : std::string()
                ));
            break;
            case 12: 
                param_stack.emplace_front(pos, action_12(*this, positions
                ));
            break;
            case 13: 
                param_stack.emplace_front(pos, action_13(*this, positions,
                    node.param_toggle[0] ? std::get<std::pair<std::string, PXML::Value>>(params[0]) : std::pair<std::string, PXML::Value>(),
                    node.param_toggle[1] ? std::get<std::map<std::string, PXML::Value>>(params[1]) : std::map<std::string, PXML::Value>()
                ));
            break;
            case 14: 
                param_stack.emplace_front(pos, action_14(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Space>(std::get<Token>(params[0])) : Tokens::Space(),
                    node.param_toggle[1] ? std::get<std::map<std::string, PXML::Value>>(params[1]) : std::map<std::string, PXML::Value>()
                ));
            break;
            case 15: 
                param_stack.emplace_front(pos, action_15(*this, positions
                ));
            break;
            case 16: 
                param_stack.emplace_front(pos, action_16(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ID>(std::get<Token>(params[0])) : Tokens::ID(),
                    node.param_toggle[1] ? std::get<Tokens::Equal>(std::get<Token>(params[1])) : Tokens::Equal(),
                    node.param_toggle[2] ? std::get<PXML::Value>(params[2]) : PXML::Value()
                ));
            break;
            case 17: 
                param_stack.emplace_front(pos, action_17(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ID>(std::get<Token>(params[0])) : Tokens::ID()
                ));
            break;
            case 18: 
                param_stack.emplace_front(pos, action_18(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Bool>(std::get<Token>(params[0])) : Tokens::Bool()
                ));
            break;
            case 19: 
                param_stack.emplace_front(pos, action_19(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Number>(std::get<Token>(params[0])) : Tokens::Number()
                ));
            break;
            case 20: 
                param_stack.emplace_front(pos, action_20(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::String>(std::get<Token>(params[0])) : Tokens::String()
                ));
            break;
            default:
            break;
        }
    };
    while(!entry_stack.empty()){
        std::variant<Node, token_t>& entry = entry_stack.front();
        if(std::holds_alternative<token_t>(entry)){
            token_t token = std::get<token_t>(entry);
            param_stack.emplace_front(token.pos, token);
            entry_stack.pop_front();
        }else if(std::holds_alternative<Node>(entry)){
            Node& node = std::get<Node>(entry);
            if(node.children.size() > 0){
                for(auto it = node.children.rbegin(); it != node.children.rend(); it = std::next(it)){
                    extract_entry(*it);
                }
                node.children.clear();
            }else{
                invoke_action(node);
                entry_stack.pop_front();
            }
        }
    }
    return std::get<PXML::Pxml>(param_stack.front().second);
}

std::list<std::pair<PxmlParser::term_t,PxmlParser::token_t>> PxmlParser::Node::flatten(){
    std::list<std::pair<term_t,token_t>> results;
    for(Entry& child : children){
        if(std::holds_alternative<token_t>(child.elem)){
            results.emplace_back(child.term, std::get<token_t>(child.elem));
        }else{
            auto flattened = std::get<Node>(child.elem).flatten();
            results.insert(results.end(), flattened.begin(), flattened.end());
        }
    }
    return results;
}

ParsePxml::ParseError::ParseError(Position pos, PxmlParser::term_t term) : pos(pos) {
    static const std::vector<std::string> terms {
        "",
        "EOF",
        "Doctype",
        "Equal",
        "Close",
        "Inline",
        "Bool",
        "Number",
        "Tag",
        "Tail",
        "String",
        "Text",
        "ID",
        "Entity",
        "Space",
        "attribute",
        "attributes",
        "body",
        "element",
        "pxml",
        "spaces",
        "text",
        "value",
    };
    msg = "unexpected " + terms[term];
}
} // namespace ParsePxml


