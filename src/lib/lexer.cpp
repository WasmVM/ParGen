// Copyright 2024 Luis Hsu
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     https://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <ParGen.hpp>
#include <Util.hpp>
#include <exception.hpp>

#include <list>
#include <unordered_map>
#include <unordered_set>

using namespace Pargen;

struct Autometa {

    Autometa(std::list<std::variant<Pargen::Rule, Pargen::State>>& rules);

    struct Action {
        enum Flags : uint8_t {
            None = 0,
            More = 1,
            Pop = 2,
            Push = 4
        };
        Flags flags = None;
        std::string content = "";
    };

    using Transition = std::variant<size_t, std::string, Action*>;

    struct State : public std::unordered_map<char, Transition> {
        bool neg = false;
        size_t fall = 0;
        size_t min = 1;
        size_t max = 1;
    };

    std::list<State> states;
    std::unordered_map<std::string, std::list<State>::iterator> state_map;
    std::list<Action> actions;

};

static void collect_rule(std::list<std::variant<Rule, Use, State>>& state, std::unordered_map<std::string, Rule>& rule_map){
    for(std::variant<Rule, Use, State>& elem : state){
        std::visit(overloaded {
            [&](Rule& rule){
                if(!rule.id.empty()){
                    rule_map[rule.id] = rule;
                }
            },
            [&](State& st){
                collect_rule(st, rule_map);
            },
            [](Use&){}
        }, elem);
    }
}

static void resolve_use(std::list<std::variant<Rule, Use, State>>& state, std::unordered_map<std::string, Rule>& rule_map){
    for(std::variant<Rule, Use, State>& elem : state){
        std::visit(overloaded {
            [&](State& st){
                resolve_use(st, rule_map);
            },
            [&](Use& use){
                if(rule_map.contains(use.id)){
                    elem.emplace<Rule>(rule_map[use.id]);
                }else{
                    throw Exception::Exception("rule id '" + use.id + "' not exist");
                }
            },
            [](Rule&){}
        }, elem);
    }
}

static void resolve_use(std::list<std::variant<Rule, State>>& rules){
    std::unordered_map<std::string, Rule> rule_map;
    for(std::variant<Rule, State>& elem : rules){
        std::visit(overloaded {
            [&](Rule& rule){
                if(!rule.id.empty()){
                    rule_map[rule.id] = rule;
                }
            },
            [&](State& state){
                collect_rule(state, rule_map);
            }
        }, elem);
    }
    for(std::variant<Rule, State>& elem : rules){
        std::visit(overloaded {
            [](Rule&){},
            [&](State& state){
                resolve_use(state, rule_map);
            }
        }, elem);
    }
}

struct Node {
    bool negate;
    std::unordered_set<char> characters;
    size_t min = 1, max = 1;
    std::list<Node> childs;
};

std::optional<> parse_pattern(std::string& pattern){
    Node root;
    Node* cur = nullptr;

    return root;
}

std::list<Autometa::State> create_states(Pargen::Rule& rule){
    std::list<Autometa::State> states;
    //Node root = parse_pattern(rule.pattern);
    return states;
}

Autometa::Autometa(std::list<std::variant<Pargen::Rule, Pargen::State>>& rules){
    resolve_use(rules);
    for(std::variant<Pargen::Rule, Pargen::State>& elem : rules){
        std::visit(overloaded {
            [&](Pargen::Rule& rule){
                std::list<Autometa::State> new_states = create_states(rule);
                auto inserted = states.insert(states.end(), new_states.begin(), new_states.end());
                if(!state_map.contains("")){
                    state_map[""] = inserted;
                }
            },
            [&](Pargen::State& state){
                // TODO:
            }
        }, elem);
    }
}

void Pargen::Lexer::generate_header(std::ostream& os){
    // prologue
    os << "/** generated by ParGen **/" << std::endl;
    {
        std::string guard = class_name;
        std::replace(guard.begin(), guard.end(), ':', '_');
        os << "#ifndef ParGen_" << guard << "_guard" << std::endl;
        os << "#define ParGen_" << guard << "_guard" << std::endl;
    }
    os << header_prologue << std::endl;
    os << "#include <iostream>" << std::endl;
    os << "#include <stack>" << std::endl;
    os << "#include <filesystem>" << std::endl;
    if(!parent.tokens.empty()){
        os << "#include " << parent.tokens.header_path.filename() << std::endl;
    }

    // pargen namespace
    os << "\nnamespace " << parent.name_space << " {\n" << std::endl;

    // Lexer class
    os << "struct " << class_name << " {" << std::endl;
    os << "    " << class_name << "(std::filesystem::path filepath, std::istream& stream);" << std::endl;
    os << "    " << parent.tokens.class_name << " get();" << std::endl;
    // Funcs
    for(std::string& func : functions){
        os << func << std::endl;
    }
    // Members
    for(std::string& member : members){
        os << member << std::endl;
    }
    os << "    Position pos;" << std::endl;
    os << "    std::string text = \"\";" << std::endl;
    os << "protected:" << std::endl;
    os << "    std::deque<size_t> stack;" << std::endl;
    os << "    size_t cur = 0;" << std::endl;
    os << "    std::istream& stream;" << std::endl;
    os << "    std::istream::int_type fetch();" << std::endl;
    os << "};\n" << std::endl;

    // close namespace
    os << "} // namespace " << parent.name_space << std::endl;

    // epilogue
    os << header_epilogue << std::endl;
    os << "#endif " << std::endl;
}

void Pargen::Lexer::generate_source(std::ostream& os){

    // Create Autometa
    Autometa autometa(*this);

    // prologue
    os << "/** generated by ParGen **/" << std::endl;
    os << "#include " << header_path << std::endl;
    os << source_prologue << std::endl;

    // includes & namespace
    os << "\nnamespace " << parent.name_space << " {\n" << std::endl;

    // constructor
    os << class_name << "::" << class_name << "(std::filesystem::path path, std::istream& stream) :\n"
        "  stream(stream)\n{\n"
        "    pos.path = path;\n"
        "}\n" << std::endl;

    // fetch
    os << "std::istream::int_type " << class_name << "::fetch(){\n"
        "    std::istream::int_type res = stream.get();\n"
        "    if(res != std::istream::traits_type::eof()){\n"
        "        text += res;\n"
        "        if(text.ends_with(\"" << new_line << "\")){\n"
        "            pos.line += 1;\n"
        "            pos.column = 0;\n"
        "        }else{\n"
        "            pos.column += 1;\n"
        "        }\n"
        "    }\n"
        "    return res;\n"
        "}\n" << std::endl;

    // states TODO: use array instead
    os << "static const std::vector<std::pair<std::pair<size_t, size_t>, size_t[256]>> __states = {" << std::endl;
    os << "};\n" << std::endl;

    // functions
    for(std::string func : functions){
        // Write function
        std::string signature = append_func_name(func, class_name);
        if(signature.starts_with("template")){
            os << "// TODO: " << signature << "\n" << std::endl;
        }else{
            os << signature << "{" << std::endl;
            os << "    // TODO: implement function here" << std::endl;
            os << "}\n" << std::endl;
        }
    }

    // get
    os << parent.tokens.class_name << " " << class_name << "::get(){" << std::endl;
    os << "}\n" << std::endl;

    // close namespace
    os << "} // namespace " << parent.name_space << "\n" << std::endl;

    // epilogue
    os << source_epilogue << std::endl;
}