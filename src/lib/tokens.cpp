// Copyright 2024 Luis Hsu
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     https://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <ParGen.hpp>
#include <iostream>

using namespace Pargen;

void Pargen::Tokens::generate_header(std::ostream& os){
    
    // prologue
    os << "/** generated by ParGen **/" << std::endl;
    {
        std::string guard = name_space + "_" + class_name;
        std::replace(guard.begin(), guard.end(), ':', '_');
        os << "#ifndef ParGen_" << guard << "_guard" << std::endl;
        os << "#define ParGen_" << guard << "_guard" << std::endl;
    }
    os << header_prologue << std::endl;
    os << "#include <iostream>" << std::endl;
    os << "#include <filesystem>" << std::endl;
    os << "#include <variant>" << std::endl;

    // pargen namespace
    os << "\nnamespace " << parent.name_space << " {\n" << std::endl;

    // Position
    os << "struct Position {" << std::endl;
    os << "    std::filesystem::path path;" << std::endl;
    os << "    size_t line;" << std::endl;
    os << "    size_t column;" << std::endl;
    os << "};"<< std::endl;

    // token namespace
    os << "\nnamespace " << name_space << " {\n" << std::endl;

    // Tokens
    std::string token_base = "std::variant<\n";
    for(Token& token : *this){
        // Declaration;
        os << "struct " << token.name << " ";
        token_base += "  " + name_space + "::" + token.name + ",\n";
        if(token.types.size() == 1){
            os << ": public " << token.types[0] << " ";
        }else if(token.types.size() > 1){
            os << ": public std::variant<";
            for(size_t i = 0; i < token.types.size(); ++i){
                if(i > 0){
                    os << ", ";
                }
                os << token.types[i];
            }
            os << "> ";
        }
        os << "{";
        // Members
        for(std::string& member : token.members){
            os << member << std::endl;
        }
        // Funcs
        for(std::string& func : token.functions){
            os << func << std::endl;
        }
        // close
        os << "};\n" << std::endl;
    }
    token_base = token_base.substr(0, token_base.size() - 2) + "\n>";

    // close namespace
    os << "} // namespace " << name_space << "\n" << std::endl;

    // Token class
    os << "struct " << class_name << " : public " << token_base << " {" << std::endl;
    // Members
    for(std::string& member : members){
        os << member << std::endl;
    }
    // Funcs
    for(std::string& func : functions){
        os << func << std::endl;
    }
    os << "    Position pos;" << std::endl;
    os << "};\n" << std::endl;

    // close namespace
    os << "} // namespace " << parent.name_space << std::endl;

    // postion output
    os << "\nstd::ostream& operator<< (std::ostream&, " << parent.name_space << "::Position&);"<< std::endl;

    // epilogue
    os << header_epilogue << std::endl;
    os << "#endif " << std::endl;
}

static std::string strip(std::string str, bool lead = true, bool trail = true){
    size_t lead_pos = lead ? str.find_first_not_of(" \t\n\r\v") : 0;
    if(trail){
        size_t trail_pos = str.find_last_not_of(" \t\n\r\v");
        return str.substr(lead_pos, trail_pos - lead_pos);
    }else{
        return str.substr(lead_pos);
    }
}

// (is_template, signature)
static std::string append_func_name(std::string func, std::string name_space){
    // Trim leading & trailing spaces
    func = strip(func);
    // Decouple function signature
    {
        std::string param;
        for(size_t i = func.size() - 1, level = 0; i > 0; --i){
            if(func[i] == ')'){
                level += 1;
            }else if(func[i] == '('){
                level -= 1;
                if(level == 0){
                    param = func.substr(i);
                    func = strip(func.substr(0, i + 1));
                }
            }
        }
        std::string name = func.substr(func.find_last_of(" \t\n\r\v") + 1);
        func = func.substr(0, func.find_last_of(" \t\n\r\v"));
        if(func.starts_with("template")){
            func = func.substr(8);
            // Get template declaration
            std::string template_args;
            for(size_t i = 0, level = 0; i < func.size(); ++i){
                if(func[i] == '<'){
                    level += 1;
                }else if(func[i] == '>'){
                    level -= 1;
                    if(level == 0){
                        template_args = func.substr(0, i + 1);
                        func = func.substr(i + 1);
                        break;
                    }
                }
            }
            func = strip(func, true, false);
            return "template<> " + func + " " + name_space + "::" + name + template_args + param;
        }else{
            return func + name_space + "::" + name + param;
        }
    }
}

void Pargen::Tokens::generate_source(std::ostream& os){
    // prologue
    os << "/** generated by ParGen **/" << std::endl;
    os << "#include " << header_path << std::endl;
    os << source_prologue << std::endl;

    // functions
    for(std::string func : functions){
        // Write function
        std::string signature = append_func_name(func, name_space);
        if(signature.starts_with("template")){
            os << "// TODO: " << signature << "\n" << std::endl;
        }else{
            os << signature << "{" << std::endl;
            os << "    // TODO: implement function here" << std::endl;
            os << "}\n" << std::endl;
        }
    }

    // Token function
    for(Token& token : *this){
        for(std::string func : token.functions){
            // Write function
            std::string signature = append_func_name(func, name_space + "::" + token.name);
            if(signature.starts_with("template")){
                os << "// TODO: " << signature << "\n" << std::endl;
            }else{
                os << signature << "{" << std::endl;
                os << "    // TODO: implement function here" << std::endl;
                os << "}\n" << std::endl;
            }
        }
    }

    // Position output
    os << "std::ostream& operator<< (std::ostream& os, " << parent.name_space << "::Position& pos){"<< std::endl;
    os << "    return os << pos.path.string() << \":\" << pos.line << \":\" << pos.column;" << std::endl;
    os << "}" << std::endl;

    // epilogue
    os << source_epilogue << std::endl;
}
