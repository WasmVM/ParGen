// Copyright 2024 Luis Hsu
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     https://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <ParGen.hpp>
#include <Util.hpp>
#include <exception.hpp>
#include <unordered_set>

#include "parser.hpp"

using namespace ::Parser;

void Pargen::Parser::generate_header(std::ostream& os){
    // prologue
    os << "/** generated by ParGen **/" << std::endl;
    {
        std::string guard = class_name;
        std::replace(guard.begin(), guard.end(), ':', '_');
        os << "#ifndef ParGen_" << guard << "_guard" << std::endl;
        os << "#define ParGen_" << guard << "_guard" << std::endl;
    }
    os << header_prologue << std::endl;

    if(!parent.tokens.empty()){
        os << "#include " << parent.tokens.header_path.filename() << std::endl;
    }
    if(parent.lexer.empty()){
        os << "#include <any>" << std::endl;
    }else{
        os << "#include " << parent.lexer.header_path.filename() << std::endl;
    }

    // pargen namespace
    os << "\nnamespace " << parent.name_space << " {\n" << std::endl;

    // Parser class
    os << "struct " << class_name << " {" << std::endl;
    os << "    " << class_name << "(" << parent.lexer.class_name << "& lexer);" << std::endl;
    os << "    " << return_type << " parse();" << std::endl;
    // Funcs
    for(std::string& func : functions){
        os << func << std::endl;
    }
    // Members
    for(std::string& member : members){
        os << member << std::endl;
    }
    os << "protected:" << std::endl;
    os << "    using id_t = size_t;" << std::endl;
    if(parent.lexer.empty()){
        os << "    using token_t = std::any;" << std::endl;
    }else{
        if(parent.lexer.return_type.empty()){
            if(parent.tokens.empty()){
                os << "    using token_t = std::any;" << std::endl;
            }else{
                os << "    using token_t = " << parent.tokens.class_name << ";" << std::endl;
            }
        }else{
            os << "    using token_t = " << parent.lexer.return_type << ";" << std::endl;
        }
        os << "    " << parent.lexer.class_name << "& lexer;" << std::endl;
    }
    os << "    std::pair<id_t,token_t> fetch();" << std::endl;
    os << "};\n" << std::endl;

    // close namespace
    os << "} // namespace " << parent.name_space << std::endl;

    // epilogue
    os << header_epilogue << std::endl;
    os << "#endif " << std::endl;
}

void Pargen::Parser::generate_source(std::ostream& os){

    ParserBase base(*this);

    // prologue
    os << "/** generated by ParGen **/" << std::endl;
    os << "#include " << header_path << std::endl;
    os << source_prologue << std::endl;

    // includes & namespace
    os << "\nnamespace " << parent.name_space << " {" << std::endl;
    if(!parent.tokens.empty()){
        os << "\nusing namespace " << parent.tokens.name_space << ";\n" << std::endl;
    }

    // constructor
    os << class_name << "::" << class_name << "(" << parent.lexer.class_name << "& lexer) : lexer(lexer) {}\n" << std::endl;

    // fetch
    os << "std::pair<" << class_name << "::id_t, " << class_name << "::token_t> " << class_name << "::fetch(){" << std::endl;
    if(!parent.lexer.empty() && parent.lexer.return_type.empty() && !parent.tokens.empty()){
        os << "    " << parent.tokens.class_name << " res = lexer.get();" << std::endl;
        os << "    return {res.index(), res};" << std::endl;
    }else{
        os << "    /* TODO: return pair as below:" << std::endl;
        std::unordered_set<std::string> nterms;
        std::transform(begin(), end(), std::inserter(nterms, nterms.end()), [](Pargen::Grammar& gram){
            return gram.target;
        });
        for(auto term_pair : base.term_map){
            if(!nterms.contains(term_pair.first)){
                os << "      {" << term_pair.second << ", " << term_pair.first << "}" << std::endl;
            }
        }
        os << "    */" << std::endl;
    }
    os << "}\n" << std::endl;

    // parse
    os << "void " << class_name << "::parse(){" << std::endl;
    
    os << "}\n" << std::endl;

    // functions
    for(std::string func : functions){
        // Write function
        std::string signature = append_func_name(func, class_name);
        if(signature.starts_with("template")){
            os << "// TODO: " << signature << "\n" << std::endl;
        }else{
            os << signature << "{" << std::endl;
            os << "    // TODO: implement function here" << std::endl;
            os << "}\n" << std::endl;
        }
    }

    // close namespace
    os << "} // namespace " << parent.name_space << "\n" << std::endl;

    // epilogue
    os << source_epilogue << std::endl;
}