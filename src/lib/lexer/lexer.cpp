// Copyright 2024 Luis Hsu
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     https://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <ParGen.hpp>
#include <Util.hpp>
#include <exception.hpp>

#include "lexer.hpp"

#include <optional>
#include <cctype>
#include <fstream>
#include <memory>
#include <map>

using namespace Pargen;

std::ostream& operator<< (std::ostream& os, CharType& type){
    if(type.negate){
        os << "not ";
    }
    if(type.is_any()){
        return os << "any";
    }
    std::string characters(type.begin(), type.end());
    std::stable_sort(characters.begin(), characters.end());
    for(char ch : characters){
        if(std::isspace(ch)){
            switch(ch){
                case ' ':
                    os << "'" << ch << "'";
                break;
                case '\t':
                    os << "\\\\t";
                break;
                case '\r':
                    os << "\\\\r";
                break;
                case '\f':
                    os << "\\\\f";
                break;
                case '\v':
                    os << "\\\\v";
                break;
                case '\n':
                    os << "\\\\n";
                break;
            }
        }else if(ch == '\"'){
            os << "'\\\"'";
        }else if(ch == '\\'){
            os << "'\\\\'";
        }else{
            os << "'" << ch << "'";
        }
    }
    return os;
}

void Pargen::Lexer::generate_header(std::ostream& os){
    // prologue
    os << "/** generated by ParGen **/" << std::endl;
    {
        std::string guard = class_name;
        std::replace(guard.begin(), guard.end(), ':', '_');
        os << "#ifndef ParGen_" << guard << "_guard" << std::endl;
        os << "#define ParGen_" << guard << "_guard" << std::endl;
    }
    os << header_prologue << std::endl;
    os << "#include <iostream>" << std::endl;
    os << "#include <deque>" << std::endl;
    os << "#include <filesystem>" << std::endl;
    os << "#include <optional>" << std::endl;
    os << "#include <map>" << std::endl;
    os << "#include <exception>" << std::endl;
    os << "#include <initializer_list>" << std::endl;
    if(!parent.tokens.empty()){
        os << "#include " << parent.tokens.header_path.filename() << std::endl;
    }

    // pargen namespace
    os << "\nnamespace " << parent.name_space << " {\n" << std::endl;

    // Syntax error
    os << "struct UnknownToken : public std::exception {" << std::endl;
    if(parent.tokens.empty()){
        os << "    UnknownToken(std::string text): msg(\"unknown token '\" + text + \"'\"){}" << std::endl;
    }else{
        os << "    UnknownToken(Position pos, std::string text): pos(pos), msg(\"unknown token '\" + text + \"'\"){}" << std::endl;
        os << "    Position pos, cur;" << std::endl;
    }
    os << "    std::string msg;" << std::endl;
    os << "    const char* what();" << std::endl;
    os << "};\n" << std::endl;

    // Lexer class
    os << "struct " << class_name << " {" << std::endl;
    os << "    " << class_name << "(std::filesystem::path filepath, std::istream& stream);" << std::endl;
    if(return_type.empty()){
        if(parent.tokens.empty()){
            os << "    void";
        }else{
            os << "    " << parent.tokens.class_name;
        }
    }else{
        os << "    " << return_type;
    }
    os  << " get();" << std::endl;
    // Funcs
    for(std::string& func : functions){
        os << func << std::endl;
    }
    // Members
    for(std::string& member : members){
        os << member << std::endl;
    }
    if(!parent.tokens.empty()){
        os << "    Position pos, cur;" << std::endl;
    }
    os << "    std::string text = \"\";\n" << std::endl;
    os << "    struct Chars {" << std::endl;
    os << "        using char_t = std::istream::int_type;" << std::endl;
    os << "        Chars(std::initializer_list<char_t> init);" << std::endl;
    os << "        Chars(char_t init) : min(init), max(init){}" << std::endl;
    os << "        bool operator<(const Chars&) const;" << std::endl;
    os << "        char_t min, max;" << std::endl;
    os << "    };\n" << std::endl;
    os << "protected:" << std::endl;
    os << "    using State = std::map<Chars, size_t>;" << std::endl;
    os << "    static std::vector<State> states;" << std::endl;
    os << "    std::deque<std::pair<size_t, std::string>> stack;" << std::endl;
    os << "    std::istream::int_type current;" << std::endl;
    os << "    size_t state;" << std::endl;
    os << "    std::string new_line = \"" << new_line << "\";" << std::endl;
    os << "    std::istream& stream;" << std::endl;
    os << "    std::istream::int_type fetch();" << std::endl;
    os << "};\n" << std::endl;

    // close namespace
    os << "} // namespace " << parent.name_space << std::endl;

    // epilogue
    os << header_epilogue << std::endl;
    os << "#endif " << std::endl;
}

void Pargen::Lexer::generate_source(std::ostream& os){

    // Create Autometa
    Autometa autometa(*this);
    // Dump autometa
    if(parent.options.debug){
        std::ofstream fout("lexer.dot");
        fout << "digraph {" << std::endl;
        autometa.dump(fout) << std::endl;
        fout << "}" << std::endl;
        fout.close();
    }

    // prologue
    os << "/** generated by ParGen **/" << std::endl;
    os << "#include " << header_path << std::endl;
    os << source_prologue << std::endl;

    // includes & namespace
    os << "\nnamespace " << parent.name_space << " {\n" << std::endl;
    if(!parent.tokens.empty()){
        os << "\nusing namespace " << parent.tokens.name_space << ";\n" << std::endl;
    }

    // constructor
    os << class_name << "::" << class_name << "(std::filesystem::path path, std::istream& stream) :\n";
    os << "  stream(stream), state(" << autometa.pxml_state_map[""] << ")\n";
    os << "{\n";
    os << "    current = fetch();\n";
    if(!parent.tokens.empty()){
        os << "    pos.path = path;\n";
    }
    os << "}\n" << std::endl;

    // Chars
    os << "PxmlLexer::Chars::Chars(std::initializer_list<Chars::char_t> init) : min(init.begin()[0]){" << std::endl;
    os << "    if(init.size() == 1){" << std::endl;
    os << "        max = init.begin()[0];" << std::endl;
    os << "    }else{" << std::endl;
    os << "        max = init.begin()[1];" << std::endl;
    os << "    }" << std::endl;
    os << "}\n" << std::endl;
    os << "bool PxmlLexer::Chars::operator<(const Chars& rhs) const {" << std::endl;
    os << "    return (min < rhs.min) && (max < rhs.min);" << std::endl;
    os << "}\n" << std::endl;

    // fetch
    os << "PxmlLexer::Chars::char_t " << class_name << "::fetch(){\n"
        "    std::string line_end = \"\";\n"
        "    Chars::char_t res = stream.get();\n"
        "    if(res != std::istream::traits_type::eof()){\n"
        "        line_end += res;\n"
        "        text += res;\n";
    if(new_line.empty() && !parent.tokens.empty()){
        os << "        cur.column += 1;\n";
    }else{
        os << "        if(line_end.size() > " << new_line.size() << "){\n"
            "            line_end = line_end.substr(line_end.size() - " <<  new_line.size() << ");\n"
            "        }\n";
        if(!parent.tokens.empty()){
            os << "        if(text.ends_with(\"" << new_line << "\")){\n"
                "            cur.line += 1;\n"
                "            cur.column = 0;\n"
                "        }else{\n"
                "            cur.column += 1;\n"
                "        }\n";
        }
    }
    os << "    }\n"
        "    return res;\n"
        "}\n" << std::endl;

    // states
    os << "std::vector<PxmlLexer::State> PxmlLexer::states = {" << std::endl;
    os << autometa << "};\n" << std::endl;

    // functions
    for(std::string func : functions){
        // Write function
        std::string signature = append_func_name(func, class_name);
        if(signature.starts_with("template")){
            os << "// TODO: " << signature << "\n" << std::endl;
        }else{
            os << signature << "{" << std::endl;
            os << "    // TODO: implement function here" << std::endl;
            os << "}\n" << std::endl;
        }
    }

    // get prologue
    if(return_type.empty()){
        if(parent.tokens.empty()){
            os << "void";
        }else{
            os << parent.tokens.class_name;
        }
    }else{
        os << return_type;
    }
    os << " " << class_name << "::get(){" << std::endl;
    os << "    if(current == std::istream::traits_type::eof()){" << std::endl;
    os << "        return Token(std::monostate(), pos);" << std::endl;
    os << "    }" << std::endl;
    os << "    while(current != std::istream::traits_type::eof()){" << std::endl;
    os << "        if(states[state].contains(current)){" << std::endl;
    os << "            state = states[state][current];" << std::endl;
    os << "            current = fetch();" << std::endl;
    os << "        }else if(states[state].contains('\\0')){" << std::endl;
    os << "            state = states[state]['\\0'];" << std::endl;
    os << "            current = fetch();" << std::endl;
    os << "        }else{" << std::endl;
    if(!parent.tokens.empty()){
        os << "            Position _pos = pos;" << std::endl;
        os << "            pos = cur;" << std::endl;
    }
    os << "            std::string _text = text.substr(0, text.size() - 1);" << std::endl;

    // actions
    std::map<size_t, std::list<size_t>> action_map;
    for(size_t state_id = 0; state_id < autometa.states.size(); ++state_id){
        Autometa::State& state = autometa.states[state_id];
        if(state.action_id){
            action_map[state.action_id.value()].emplace_back(state_id);
        }
    }
    os << "            switch(state){";
    for(auto& action_pair : action_map){
        Autometa::Action& action = autometa.actions[action_pair.first];
        os << "\n                // Action " << action_pair.first;
        for(size_t& state_id : action_pair.second){
            os << "\n                case " << state_id << ":";
        }
        if(action.flags & Autometa::Action::Pop){
            if(action.push){
                os << "\n                    state = " << autometa.pxml_state_map[action.push.value()] <<";";      
                if(!(action.flags & Autometa::Action::More)){
                    os << "\n                    text = current;";
                }
            }else{
                os << "\n                    state = stack.back().first;";
                if(action.flags & Autometa::Action::More){
                    os << "\n                    text = stack.back().second + text;";
                }else{
                    os << "\n                    text = current;";
                }
                os << "\n                    stack.pop_back();";
            }
        }else{
            if(action.push){
                os << "\n                    stack.emplace_back(" << autometa.pxml_state_map[action.pxml_state] << ", text);"; 
                os << "\n                    state = " << autometa.pxml_state_map[action.push.value()] <<";";
            }else{
                os << "\n                    state = " << autometa.pxml_state_map[action.pxml_state] <<";";
            }
            if(!(action.flags & Autometa::Action::More)){
                os << "\n                    text = current;";
            }
        }
        if(action.content.empty()){
            os << "\n                break;";
        }else{
            os << "\n                {";
            os << handle_indent(20, action.content) << std::endl;
            os << "                }break;";
        }
    }

    // get epilogue
    os << "\n                default:" << std::endl;
    if(parent.tokens.empty()){
        os << "                    throw UnknownToken(text);" << std::endl;
    }else{
        os << "                    throw UnknownToken(_pos, text);" << std::endl;
    }
    os << "            }" << std::endl;
    os << "        }" << std::endl;
    os << "    }" << std::endl;
    os << "}\n" << std::endl;

    // UnknownToken
    os << "const char* UnknownToken::what(){" << std::endl;
    os << "    return msg.c_str();" << std::endl;
    os << "}\n" << std::endl;

    // close namespace
    os << "} // namespace " << parent.name_space << "\n" << std::endl;

    // epilogue
    os << source_epilogue << std::endl;
}